//
// Generated by Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
//
//
// Buffer Definitions: 
//
// cbuffer CBPerMesh
// {
//
//   row_major float4x4 World_view_projection;// Offset:    0 Size:    64
//   row_major float4x4 world;          // Offset:   64 Size:    64 [unused]
//   float4 material_color;             // Offset:  128 Size:    16 [unused]
//   float4 light_direction;            // Offset:  144 Size:    16 [unused]
//   row_major float4x4 bone_transforms[32];// Offset:  160 Size:  2048
//
// }
//
//
// Resource Bindings:
//
// Name                                 Type  Format         Dim Slot Elements
// ------------------------------ ---------- ------- ----------- ---- --------
// CBPerMesh                         cbuffer      NA          NA    0        1
//
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// POSITION                 0   xyz         0     NONE   float   xyz 
// COLOR                    0   xyzw        1     NONE   float       
// NORMAL                   0   xyzw        2     NONE   float       
// TEXCOORD                 0   xy          3     NONE   float   xy  
// WEIGHTS                  0   xyzw        4     NONE   float   xyzw
// BONES                    0   xyzw        5     NONE    uint   xyzw
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_POSITION              0   xyzw        0      POS   float   xyzw
// COLOR                    0   xyzw        1     NONE   float   xyzw
// TEXCOORD                 0   xy          2     NONE   float   xy  
// NORMAL                   0   xyz         3     NONE   float   xyz 
// TEXCOORD                 1   xyz         4     NONE   float   xyz 
//
//
// Constant buffer to DX9 shader constant mappings:
//
// Target Reg Buffer  Start Reg # of Regs        Data Conversion
// ---------- ------- --------- --------- ----------------------
// c0         cb0             0       138  ( FLT, FLT, FLT, FLT)
//
//
// Runtime generated constant mappings:
//
// Target Reg                               Constant Description
// ---------- --------------------------------------------------
// c143                            Vertex Shader position offset
//
//
// Level9 shader bytecode:
//
    vs_2_x
    def c142, 4, 0, 1, 0
    def c138, 1, 0, 0, 0
    def c139, 0, 1, 0, 0
    def c140, 0, 0, 1, 0
    def c141, 0, 0, 0, 1
    defi i0, 4, 0, 1, 0
    dcl_texcoord v0  // input<0,1,2>
    dcl_texcoord3 v3  // input<11,12>
    dcl_texcoord4 v4  // input<13,14,15,16>
    dcl_texcoord5 v5  // input<17,18,19,20>

#line 18 "C:\Users\2170267.MAETEL\Desktop\testç”¨3dgp\Shader_test_vs.hlsl"
    mov r0.xyz, c138.w  // ::p<0,1,2>
    loop aL, i0
      dp4 r0.w, v4, c138[aL]
      dp4 r1.x, v5, c138[aL]
      mul r1.x, r1.x, c142.x
      mova a0.x, r1.x
      mul r1.xyz, v0.x, c10[a0.x]
      mul r2.xyz, v0.y, c11[a0.x]
      add r1.xyz, r1, r2
      mul r2.xyz, v0.z, c12[a0.x]
      add r1.xyz, r1, r2
      mov r2.x, c138.x
      mul r2.xyz, r2.x, c13[a0.x]
      add r1.xyz, r1, r2
      mul r1.xyz, r0.w, r1
      add r0.xyz, r0, r1  // ::p<0,1,2>
    endloop

#line 31
    mul r1, r0.x, c0
    mul r2, r0.y, c1
    add r1, r1, r2
    mul r0, r0.z, c2
    add r0, r0, r1  // ::worldPos<0,1,2,3>
    mov r0, r0  // ::output<0,1,2,3>

#line 47
    mov r1.xy, v3  // ::output<8,9>

#line 67
    mov r0.xy, r0  // ::main<0,1>
    mov r0.zw, r0  // ::main<2,3>
    mov oT1.xy, r1  // ::main<8,9>

#line 6
    mul r1.xy, r0.w, c143
    add oPos.xy, r0, r1  // ::main<0,1>
    mov oPos.zw, r0  // ::main<2,3>
    mov oT0, c138.w  // ::main<4,5,6,7>
    mov oT2.xyz, c138.w  // ::main<10,11,12>
    mov oT3.xyz, c138.w  // ::main<13,14,15>

// approximately 36 instruction slots used
vs_4_0
dcl_immediateConstantBuffer { { 1.000000, 0, 0, 0},
                              { 0, 1.000000, 0, 0},
                              { 0, 0, 1.000000, 0},
                              { 0, 0, 0, 1.000000},
                              { -1, 0, 0, 0},
                              { 0, -1, 0, 0},
                              { 0, 0, -1, 0},
                              { 0, 0, 0, -1} }
dcl_constantbuffer cb0[138], dynamicIndexed
dcl_input v0.xyz
dcl_input v3.xy
dcl_input v4.xyzw
dcl_input v5.xyzw
dcl_output_siv o0.xyzw, position
dcl_output o1.xyzw
dcl_output o2.xy
dcl_output o3.xyz
dcl_output o4.xyz
dcl_temps 7
//
// Initial variable locations:
//   v0.x <- input.Position.x; v0.y <- input.Position.y; v0.z <- input.Position.z; 
//   v1.x <- input.Color.x; v1.y <- input.Color.y; v1.z <- input.Color.z; v1.w <- input.Color.w; 
//   v2.x <- input.Normal.x; v2.y <- input.Normal.y; v2.z <- input.Normal.z; v2.w <- input.Normal.w; 
//   v3.x <- input.Tex.x; v3.y <- input.Tex.y; 
//   v4.x <- input.bone_weights.x; v4.y <- input.bone_weights.y; v4.z <- input.bone_weights.z; v4.w <- input.bone_weights.w; 
//   v5.x <- input.bone_indices.x; v5.y <- input.bone_indices.y; v5.z <- input.bone_indices.z; v5.w <- input.bone_indices.w; 
//   o4.x <- <main return value>.ViewVec.x; o4.y <- <main return value>.ViewVec.y; o4.z <- <main return value>.ViewVec.z; 
//   o3.x <- <main return value>.Normal.x; o3.y <- <main return value>.Normal.y; o3.z <- <main return value>.Normal.z; 
//   o2.x <- <main return value>.Tex.x; o2.y <- <main return value>.Tex.y; 
//   o1.x <- <main return value>.Color.x; o1.y <- <main return value>.Color.y; o1.z <- <main return value>.Color.z; o1.w <- <main return value>.Color.w; 
//   o0.x <- <main return value>.Position.x; o0.y <- <main return value>.Position.y; o0.z <- <main return value>.Position.z; o0.w <- <main return value>.Position.w
//
#line 8 "C:\Users\2170267.MAETEL\Desktop\test—p3dgp\Shader_test_vs.hls"
itof r0.xyzw, l(0, 0, 0, 0)  // r0.x <- output.Color.x; r0.y <- output.Color.y; r0.z <- output.Color.z; r0.w <- output.Color.w
itof r1.xyz, l(0, 0, 0, 0)  // r1.x <- output.Normal.x; r1.y <- output.Normal.y; r1.z <- output.Normal.z
itof r2.xyz, l(0, 0, 0, 0)  // r2.x <- output.ViewVec.x; r2.y <- output.ViewVec.y; r2.z <- output.ViewVec.z

#line 15
itof r3.xyz, l(0, 0, 0, 0)  // r3.x <- p.x; r3.y <- p.y; r3.z <- p.z

#line 18
mov r1.w, l(0)  // r1.w <- index_bone
mov r4.xyz, r3.xyzx  // r4.x <- p.x; r4.y <- p.y; r4.z <- p.z
mov r2.w, r1.w  // r2.w <- index_bone
loop 
  ilt r3.w, r2.w, l(4)
  breakc_z r3.w
  dp4 r3.w, v4.xyzw, icb[r2.w + 0].xyzw
  and r5.xyzw, v5.xyzw, icb[r2.w + 4].xyzw
  or r5.xy, r5.ywyy, r5.xzxx
  or r4.w, r5.y, r5.x
  imul null, r4.w, r4.w, l(4)
  mul r5.xyz, v0.xxxx, cb0[r4.w + 10].xyzx
  mul r6.xyz, v0.yyyy, cb0[r4.w + 11].xyzx
  add r5.xyz, r5.xyzx, r6.xyzx
  mul r6.xyz, v0.zzzz, cb0[r4.w + 12].xyzx
  add r5.xyz, r5.xyzx, r6.xyzx
  mul r6.xyz, l(1.000000, 1.000000, 1.000000, 0.000000), cb0[r4.w + 13].xyzx
  add r5.xyz, r5.xyzx, r6.xyzx
  mul r5.xyz, r3.wwww, r5.xyzx
  add r4.xyz, r4.xyzx, r5.xyzx
  iadd r2.w, r2.w, l(1)
endloop 

#line 31
mul r3.xyzw, r4.xxxx, cb0[0].xyzw
mul r5.xyzw, r4.yyyy, cb0[1].xyzw
add r3.xyzw, r3.xyzw, r5.xyzw
mul r4.xyzw, r4.zzzz, cb0[2].xyzw
add r3.xyzw, r3.xyzw, r4.xyzw  // r3.x <- worldPos.x; r3.y <- worldPos.y; r3.z <- worldPos.z; r3.w <- worldPos.w
mov r3.xyzw, r3.xyzw  // r3.x <- output.Position.x; r3.y <- output.Position.y; r3.z <- output.Position.z; r3.w <- output.Position.w

#line 47
mov r4.xy, v3.xyxx  // r4.x <- output.Tex.x; r4.y <- output.Tex.y

#line 67
mov o0.xyzw, r3.xyzw
mov o1.xyzw, r0.xyzw
mov o3.xyz, r1.xyzx
mov o4.xyz, r2.xyzx
mov o2.xy, r4.xyxx
ret 
// Approximately 39 instruction slots used
